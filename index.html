<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flying Emoji</title>
    
    <!-- [ì¤‘ìš”] êµ¬ê¸€ ì• ë“œì„¼ìŠ¤ ìë™ ê´‘ê³  ìŠ¤í¬ë¦½íŠ¸ -->
    <!-- ì•„ë˜ ca-pub- ë’¤ì˜ ìˆ«ìë¥¼ ë³¸ì¸ì˜ ì‹¤ì œ ê²Œì‹œì IDë¡œ ë³€ê²½í•˜ì„¸ìš” -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4900244474968005"
     crossorigin="anonymous"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');
        
        body {
            font-family: 'Jua', sans-serif;
            overflow: hidden;
            touch-action: none; /* ëª¨ë°”ì¼ì—ì„œ ìŠ¤í¬ë¡¤ ë°©ì§€ */
            background-color: #70c5ce; /* í•˜ëŠ˜ìƒ‰ ë°°ê²½ */
            transition: background-color 1s ease; /* ë°°ê²½ìƒ‰ ë³€ê²½ ì‹œ ë¶€ë“œëŸ½ê²Œ */
            -webkit-user-select: none; /* í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .game-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50; /* ë ˆì´ì–´ ìˆœì„œ í™•ì‹¤íˆ ì•ìœ¼ë¡œ */
        }
        .interactive {
            pointer-events: auto;
        }
        /* ë²„íŠ¼ ëˆŒë¦¼ íš¨ê³¼ */
        .btn-press:active {
            transform: scale(0.95);
        }
        /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas"></canvas>

    <!-- ì ìˆ˜ í‘œì‹œ (ê²Œì„ ì¤‘) -->
    <div id="highScoreDisplay" class="absolute top-4 left-0 w-full text-center text-2xl text-yellow-300 font-bold drop-shadow-md hidden select-none pointer-events-none z-10">
        Best: 0
    </div>
    <div id="scoreDisplay" class="absolute top-12 left-0 w-full text-center text-5xl text-white font-bold drop-shadow-md hidden select-none pointer-events-none z-10">
        0
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="startScreen" class="game-layer bg-black/40 backdrop-blur-sm">
        <div class="bg-white/90 p-8 rounded-2xl shadow-2xl text-center interactive max-w-sm mx-4 border-4 border-blue-400">
            <h1 class="text-5xl font-bold text-blue-600 mb-2">Flying Emoji</h1>
            <p id="themeTitle" class="text-gray-600 mb-4 text-lg">ì´ëª¨ì§€ê°€ ë˜ì–´ ê±´ë¬¼ ì‚¬ì´ë¥¼ ë‚ ì•„ë³´ì„¸ìš”!</p>
            
            <div id="demoEmoji" class="text-6xl animate-bounce mb-4 transition-all duration-500">ğŸ¤ª</div>
            
            <p class="text-sm text-gray-500 mb-6">í„°ì¹˜ ë˜ëŠ” í´ë¦­ìœ¼ë¡œ ì í”„<br>5ì ë§ˆë‹¤ ì†ë„ê°€ ë¹¨ë¼ì§‘ë‹ˆë‹¤!</p>
            
            <div class="flex flex-col gap-3 w-full">
                <button id="startBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-10 rounded-full text-xl shadow-lg btn-press transition-colors">
                    ê²Œì„ ì‹œì‘
                </button>
                
                <!-- Gemini AI ë²„íŠ¼ -->
                <button id="aiThemeBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-10 rounded-full text-lg shadow-lg btn-press transition-colors flex justify-center items-center">
                    <span>âœ¨ AI í…Œë§ˆ ë³€ê²½</span>
                </button>
            </div>
            <p id="aiStatus" class="text-xs text-purple-600 mt-2 h-4"></p>
        </div>
    </div>

    <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
    <div id="gameOverScreen" class="game-layer bg-black/60 backdrop-blur-md hidden" style="display: none;">
        <div class="bg-white/90 p-8 rounded-2xl shadow-2xl text-center interactive max-w-sm mx-4 border-4 border-red-400 relative">
            <h2 class="text-5xl font-bold text-red-500 mb-4">ê²Œì„ ì˜¤ë²„!</h2>
            <div class="flex justify-center space-x-8 mb-6">
                <div class="text-center">
                    <p class="text-gray-500 text-sm">ì ìˆ˜</p>
                    <p id="finalScore" class="text-4xl font-bold text-gray-800">0</p>
                </div>
                <div class="text-center">
                    <p class="text-gray-500 text-sm">ìµœê³  ì ìˆ˜</p>
                    <p id="bestScore" class="text-4xl font-bold text-yellow-500">0</p>
                </div>
            </div>
            <!-- ëª¨ë°”ì¼ì—ì„œ í„°ì¹˜í•˜ê¸° ì‰½ë„ë¡ ë²„íŠ¼ í¬ê¸° í™•ëŒ€ -->
            <button id="restartBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-12 rounded-full text-3xl shadow-lg btn-press w-full">
                ë‹¤ì‹œ í•˜ê¸°
            </button>
        </div>
    </div>

    <script>
        // --- Gemini API ì„¤ì • ---
        const apiKey = "AIzaSyDx5c2u3CdSHPwzSMLzYCdLQKwHNXvmsOk"; // API í‚¤ëŠ” ì‹¤í–‰ í™˜ê²½ì—ì„œ ìë™ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤.

        // --- ê²Œì„ ì„¤ì • ë° ë³€ìˆ˜ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI ìš”ì†Œ
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const bestScoreEl = document.getElementById('bestScore');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const aiThemeBtn = document.getElementById('aiThemeBtn');
        const aiStatus = document.getElementById('aiStatus');
        const themeTitle = document.getElementById('themeTitle');
        const demoEmoji = document.getElementById('demoEmoji');

        // ì˜¤ë””ì˜¤ ì„¤ì • (ë™ì „ íš¨ê³¼ìŒ)
        const coinSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3');
        coinSound.volume = 0.5; 

        // [ìˆ˜ì •ë¨] Web Audio API ê¸°ë°˜ BGM ìƒì„±ê¸° (íŒŒì¼ ë¡œë”© ì—†ìŒ = ì—ëŸ¬ 0%)
        // ì½”ë“œë¡œ ì§ì ‘ ë©œë¡œë””ë¥¼ ì—°ì£¼í•˜ë¯€ë¡œ ë§í¬ê°€ ëŠê¸¸ ì¼ì´ ì—†ìŠµë‹ˆë‹¤.
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // ê°„ë‹¨í•œ ë©œë¡œë”” ì‹œí€€ìŠ¤ (If I Had a Chicken ìŠ¤íƒ€ì¼ì˜ í†µí†µ íŠ€ëŠ” ëŠë‚Œ)
        const melody = [
            { note: 261.63, duration: 0.2 }, { note: 0, duration: 0.1 }, // C4
            { note: 329.63, duration: 0.2 }, { note: 0, duration: 0.1 }, // E4
            { note: 392.00, duration: 0.2 }, { note: 0, duration: 0.1 }, // G4
            { note: 329.63, duration: 0.2 }, { note: 0, duration: 0.1 }, // E4
            { note: 261.63, duration: 0.2 }, { note: 0, duration: 0.1 }, // C4
            { note: 329.63, duration: 0.2 }, { note: 0, duration: 0.1 }, // E4
            { note: 293.66, duration: 0.4 }, { note: 0, duration: 0.2 }, // D4
            
            { note: 293.66, duration: 0.2 }, { note: 0, duration: 0.1 }, // D4
            { note: 349.23, duration: 0.2 }, { note: 0, duration: 0.1 }, // F4
            { note: 392.00, duration: 0.2 }, { note: 0, duration: 0.1 }, // G4
            { note: 349.23, duration: 0.2 }, { note: 0, duration: 0.1 }, // F4
            { note: 293.66, duration: 0.2 }, { note: 0, duration: 0.1 }, // D4
            { note: 349.23, duration: 0.2 }, { note: 0, duration: 0.1 }, // F4
            { note: 261.63, duration: 0.4 }, { note: 0, duration: 0.2 }, // C4
        ];
        
        let noteIndex = 0;
        let nextNoteTime = 0;
        let isPlayingBgm = false;
        let timerID;

        function playBgmNote() {
            if (!isPlayingBgm) return;

            const now = audioCtx.currentTime;
            
            // ë‹¤ìŒ ìŒì„ ì˜ˆì•½í•  ì‹œê°„ì´ ë˜ì—ˆëŠ”ì§€ í™•ì¸ (0.1ì´ˆ ë¯¸ë¦¬ ì˜ˆì•½)
            while (nextNoteTime < now + 0.1) {
                const noteData = melody[noteIndex];
                
                if (noteData.note > 0) {
                    const osc = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    
                    osc.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    
                    // ê·€ì—½ê³  í†µí†µ íŠ€ëŠ” ì†Œë¦¬ (Triangle Wave)
                    osc.type = 'triangle'; 
                    osc.frequency.value = noteData.note;
                    
                    // ì§§ê³  êµµê²Œ (Envelope)
                    gainNode.gain.setValueAtTime(0.1, nextNoteTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + noteData.duration);
                    
                    osc.start(nextNoteTime);
                    osc.stop(nextNoteTime + noteData.duration);
                }

                // ë‹¤ìŒ ìŒìœ¼ë¡œ ì´ë™
                nextNoteTime += noteData.duration;
                noteIndex = (noteIndex + 1) % melody.length;
            }
            
            timerID = requestAnimationFrame(playBgmNote);
        }

        function startBgm() {
            if (isPlayingBgm) return;
            
            // AudioContextëŠ” ì‚¬ìš©ì ì œìŠ¤ì²˜ í›„ ì¬ê°œ í•„ìš”
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            isPlayingBgm = true;
            noteIndex = 0;
            nextNoteTime = audioCtx.currentTime + 0.1;
            playBgmNote();
        }

        function stopBgm() {
            isPlayingBgm = false;
            cancelAnimationFrame(timerID);
        }

        // ê²Œì„ ìƒíƒœ
        let gameState = 'START'; 
        let frames = 0;
        let score = 0;
        let highScore = localStorage.getItem('flyingEmojiHighScore') || 0;
        
        // ì†ë„ ê´€ë ¨ ë³€ìˆ˜ 
        let baseSpeed = 3; 
        let maxSpeed = 4.5;
        let speedIncrement = 0.3;
        let gameSpeed = 3;
        
        // ì…ë ¥ ë”œë ˆì´
        let inputLocked = false;

        // ì´ëª¨ì§€ ë°ì´í„° (ê¸°ë³¸ê°’)
        let faceEmojis = ['ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ¥²', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜', 'ğŸ¤©', 'ğŸ¥³', 'ğŸ¥´', 'ğŸ¤¯', 'ğŸ¤ ', 'ğŸ¥º', 'ğŸ˜¡', 'ğŸ˜±'];
        let buildingEmojis = ['ğŸ¢', 'ğŸ¬', 'ğŸ­', 'ğŸ¥', 'ğŸ¦', 'ğŸ«', 'ğŸ¨'];

        // --- Gemini AI í…Œë§ˆ ìƒì„± ë¡œì§ ---
        async function generateAITheme() {
            if (!apiKey) {
                console.warn("API Key not found.");
                aiStatus.innerText = "API í‚¤ ì˜¤ë¥˜";
                return;
            }

            aiThemeBtn.disabled = true;
            aiThemeBtn.innerHTML = '<span class="loader"></span> ìƒì„± ì¤‘...';
            aiStatus.innerText = "Geminiê°€ ì°½ì˜ì ì¸ í…Œë§ˆë¥¼ ìƒê° ì¤‘ì…ë‹ˆë‹¤...";

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: "Create a fun, creative, random theme for a Flappy Bird style game. Return ONLY a JSON object with these fields: 'title' (Korean string, e.g., 'Space Adventure'), 'playerEmojis' (array of 5-10 distinct emoji strings for the character), 'obstacleEmojis' (array of 5-10 distinct emoji strings for obstacles), 'backgroundColor' (hex color string for the sky). Ensure emojis are fun and related to the theme."
                            }]
                        }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    title: { type: "STRING" },
                                    playerEmojis: { type: "ARRAY", items: { type: "STRING" } },
                                    obstacleEmojis: { type: "ARRAY", items: { type: "STRING" } },
                                    backgroundColor: { type: "STRING" }
                                }
                            }
                        }
                    })
                });

                if (!response.ok) throw new Error('Network response was not ok');

                const data = await response.json();
                const theme = JSON.parse(data.candidates[0].content.parts[0].text);

                applyTheme(theme);
                aiStatus.innerText = "í…Œë§ˆ ì ìš© ì™„ë£Œ! âœ¨";

            } catch (error) {
                console.error('AI Error:', error);
                aiStatus.innerText = "ìƒì„± ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
            } finally {
                aiThemeBtn.disabled = false;
                aiThemeBtn.innerHTML = '<span>âœ¨ AI í…Œë§ˆ ë³€ê²½</span>';
                setTimeout(() => { aiStatus.innerText = ""; }, 3000);
            }
        }

        function applyTheme(theme) {
            faceEmojis = theme.playerEmojis;
            buildingEmojis = theme.obstacleEmojis;
            
            themeTitle.innerText = `í˜„ì¬ í…Œë§ˆ: ${theme.title}`;
            document.body.style.backgroundColor = theme.backgroundColor;
            
            demoEmoji.innerText = faceEmojis[0];
            
            if (bird) {
                bird.currentEmoji = faceEmojis[0];
            }
        }

        aiThemeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            generateAITheme();
        });
        aiThemeBtn.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            generateAITheme();
        }, {passive: false});

        // --- ê¸°ì¡´ ê²Œì„ ë¡œì§ ---

        function setGameSpeedParams() {
            const ua = navigator.userAgent;
            const isAndroid = /Android/i.test(ua);
            const isIOS = /iPhone|iPad|iPod/i.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            if (isAndroid || isIOS) {
                baseSpeed = 2.25; 
            } else {
                baseSpeed = 3;    
            }
            
            maxSpeed = baseSpeed * 1.5;
            speedIncrement = baseSpeed * 0.1;
            
            if (gameState === 'START') {
                gameSpeed = baseSpeed;
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            setGameSpeedParams(); 
            if (bird) bird.updateDimensions();
        }
        window.addEventListener('resize', resizeCanvas);

        // --- ê°ì²´ í´ë˜ìŠ¤ ---

        const bird = {
            x: 50,
            y: 150,
            radius: 20,
            velocity: 0,
            gravity: 0.25,
            jumpStrength: 7, 
            currentEmoji: 'ğŸ˜€',
            rotation: 0,

            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                let targetRotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
                this.rotation = targetRotation;
                ctx.rotate(this.rotation);
                
                const fontSize = (this.radius && this.radius > 0) ? this.radius * 2.2 : 44;
                ctx.font = `${fontSize}px Arial`; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.currentEmoji, 0, 5); 
                ctx.restore();
            },

            update: function() {
                this.velocity += this.gravity;
                this.y += this.velocity;

                if (this.y + this.radius >= canvas.height - 20) { 
                    this.y = canvas.height - 20 - this.radius;
                    gameOver();
                }

                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            },

            jump: function() {
                this.velocity = -this.jumpStrength;
                this.currentEmoji = faceEmojis[Math.floor(Math.random() * faceEmojis.length)];
            },
            
            updateDimensions: function() {
                this.radius = Math.min(window.innerWidth, window.innerHeight) * 0.05; 
                if (this.radius < 15) this.radius = 15;
                if (this.radius > 30) this.radius = 30;
            },

            resetPosition: function() {
                this.x = canvas.width * 0.2; 
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.currentEmoji = faceEmojis.length > 0 ? faceEmojis[0] : 'ğŸ˜€';
                this.updateDimensions(); 
            }
        };

        const obstacles = {
            list: [],
            distanceSinceLastSpawn: 0, 
            nextSpawnDistance: 0,      
            
            draw: function() {
                for (let i = 0; i < this.list.length; i++) {
                    let obs = this.list[i];
                    if (!obs) continue; 
                    
                    ctx.fillStyle = '#777'; 

                    let emojiSize = obs.width;
                    if (!emojiSize || emojiSize <= 0) emojiSize = 40;

                    ctx.font = `${emojiSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    
                    for (let y = obs.top; y > -emojiSize; y -= emojiSize * 0.8) {
                         ctx.fillText(obs.buildingType, obs.x + obs.width/2, y);
                    }

                    ctx.textBaseline = 'top';
                    for (let y = canvas.height - obs.bottom; y < canvas.height + emojiSize; y += emojiSize * 0.8) {
                        ctx.fillText(obs.buildingType, obs.x + obs.width/2, y);
                    }
                }
            },

            update: function() {
                this.distanceSinceLastSpawn += gameSpeed;

                if (this.distanceSinceLastSpawn >= this.nextSpawnDistance) {
                    
                    const minHeight = canvas.height * 0.1;
                    const availableHeight = canvas.height - (minHeight * 2);
                    
                    let maxGap = Math.max(160, canvas.height * 0.25) * 1.2;
                    let minGap = (bird.radius * 2.2) * 3.0;
                    
                    if (minGap > availableHeight) minGap = availableHeight * 0.8;
                    if (maxGap > availableHeight) maxGap = availableHeight;
                    
                    const actualMaxGap = Math.max(maxGap, minGap + 10);
                    
                    let gap = Math.random() * (actualMaxGap - minGap) + minGap;
                    if (gap > availableHeight) gap = availableHeight;

                    const maxTop = canvas.height - minHeight - gap;
                    
                    let topHeight;
                    if (maxTop <= minHeight) {
                        topHeight = minHeight; 
                    } else {
                        topHeight = Math.floor(Math.random() * (maxTop - minHeight + 1) + minHeight);
                    }
                    
                    const bottomHeight = Math.max(minHeight, canvas.height - gap - topHeight);

                    this.list.push({
                        x: canvas.width,
                        width: bird.radius * 3.5, 
                        top: topHeight,
                        bottom: bottomHeight,
                        passed: false,
                        buildingType: buildingEmojis[Math.floor(Math.random() * buildingEmojis.length)]
                    });

                    const baseDistance = bird.radius * 22;
                    const minDistance = baseDistance * 0.5;
                    const maxDistance = baseDistance * 1.2;
                    this.nextSpawnDistance = Math.random() * (maxDistance - minDistance) + minDistance;
                    this.distanceSinceLastSpawn = 0;
                }

                for (let i = 0; i < this.list.length; i++) {
                    let obs = this.list[i];
                    obs.x -= gameSpeed;

                    const hitBoxPadding = bird.radius * 0.6; 

                    const birdLeft = bird.x - bird.radius + hitBoxPadding;
                    const birdRight = bird.x + bird.radius - hitBoxPadding;
                    const birdTop = bird.y - bird.radius + hitBoxPadding;
                    const birdBottom = bird.y + bird.radius - hitBoxPadding;

                    if (birdRight > obs.x && birdLeft < obs.x + obs.width && birdTop < obs.top) {
                        gameOver();
                    }
                    if (birdRight > obs.x && birdLeft < obs.x + obs.width && birdBottom > canvas.height - obs.bottom) {
                        gameOver();
                    }

                    if (obs.x + obs.width < bird.x && !obs.passed) {
                        score++;
                        scoreDisplay.innerText = score;
                        obs.passed = true;
                        
                        if (score % 5 === 0) {
                            coinSound.currentTime = 0;
                            coinSound.play().catch(e => console.log('Audio error handled'));

                            if (gameSpeed < maxSpeed) {
                                gameSpeed += speedIncrement;
                                if (gameSpeed > maxSpeed) gameSpeed = maxSpeed;
                            }
                        }
                    }

                    if (obs.x + obs.width < 0) {
                        this.list.shift();
                        i--;
                    }
                }
            },
            
            reset: function() {
                this.list = [];
                gameSpeed = baseSpeed;
                this.distanceSinceLastSpawn = 0;
                const radius = (bird.radius && bird.radius > 0) ? bird.radius : 20;
                this.nextSpawnDistance = radius * 22;
            }
        };

        const background = {
            clouds: [],
            draw: function() {
                ctx.fillStyle = '#ded895'; 
                ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.clouds.forEach(cloud => {
                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.size * 0.7, cloud.y - cloud.size * 0.5, cloud.size * 0.8, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.size * 1.4, cloud.y, cloud.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            },
            update: function() {
                if (Math.random() < 0.01) {
                    this.clouds.push({
                        x: canvas.width + 50,
                        y: Math.random() * (canvas.height * 0.6),
                        size: Math.random() * 30 + 20,
                        speed: Math.random() * 0.5 + 0.2
                    });
                }
                for (let i = 0; i < this.clouds.length; i++) {
                    let cloud = this.clouds[i];
                    cloud.x -= cloud.speed;
                    if (cloud.x < -100) {
                        this.clouds.shift();
                        i--;
                    }
                }
            }
        };

        // --- ê²Œì„ ë¡œì§ ---

        function initGame() {
            bird.resetPosition();
            obstacles.reset();
            score = 0;
            frames = 0;
            
            scoreDisplay.innerText = score;
            highScoreDisplay.innerText = `Best: ${highScore}`;

            scoreDisplay.classList.remove('hidden');
            highScoreDisplay.classList.remove('hidden');
        }

        function startGame() {
            if (gameState === 'PLAYING') return;

            gameState = 'PLAYING';
            
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';

            // [ìˆ˜ì •ë¨] ì½”ë“œë¡œ ë§Œë“  BGM ì‹œì‘
            startBgm();
            
            initGame();
            
            inputLocked = true;
            setTimeout(() => {
                inputLocked = false;
            }, 60);

            if (!animationId) {
                loop();
            }
        }

        let animationId;

        function gameOver() {
            if (gameState === 'GAMEOVER') return;
            gameState = 'GAMEOVER';

            // [ìˆ˜ì •ë¨] BGM ì •ì§€
            stopBgm();
            
            scoreDisplay.classList.add('hidden');
            highScoreDisplay.classList.add('hidden');
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flyingEmojiHighScore', highScore);
            }
            
            finalScoreEl.innerText = score;
            bestScoreEl.innerText = highScore;
            
            gameOverScreen.style.display = 'flex';
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            background.update();
            background.draw();

            if (gameState === 'PLAYING') {
                obstacles.update();
                obstacles.draw();
                bird.update();
                bird.draw();
                frames++;
            } else if (gameState === 'GAMEOVER') {
                obstacles.draw();
                bird.draw();
            } else if (gameState === 'START') {
                background.update();
            }

            animationId = requestAnimationFrame(loop);
        }

        // --- ì…ë ¥ ë° ì´ë²¤íŠ¸ ì²˜ë¦¬ ---

        function handleGameInput(e) {
            if (inputLocked || gameState !== 'PLAYING') return;
            
            if (e.target === canvas && e.cancelable) {
                e.preventDefault();
            }
            
            bird.jump();
        }

        function handleButtonClick(e) {
            e.stopPropagation();
            if (e.cancelable) e.preventDefault();
            
            startGame();
        }

        canvas.addEventListener('touchstart', handleGameInput, {passive: false});
        canvas.addEventListener('mousedown', handleGameInput);
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (gameState === 'PLAYING') handleGameInput(e);
                else handleButtonClick(e); 
            }
        });

        startBtn.addEventListener('touchend', handleButtonClick, {passive: false});
        startBtn.addEventListener('click', handleButtonClick);
        
        restartBtn.addEventListener('touchend', handleButtonClick, {passive: false});
        restartBtn.addEventListener('click', handleButtonClick);

        resizeCanvas();
        loop();

    </script>
</body>
</html>
